# module 
require('모듈이름') 
js파일을 모듈화하기 위해 사용하는 내장객체 // /usr/share/doc/nodejs/api 하위 모듈

- custom_module.js ( 커스텀 모듈을 만듦 )
// 1. exports 객체를 사용해서 sum이라는 변수를 만들고, sum 변수에 function 을 사용해서 하나의 파라미터를 가진 함수식을 대입
exports.sum = function(max) {
    // 2. 입력된 값을 최대값으로 1부터 최대값까지 더해서 반환하는 로직
    return (max+1)*max/2;
}

// 3. var1 변수에 'NEW VALUE 100' 입력
exports.var1 = 'NEW VALUE 100';

- home.js ( 커스텀 모듈을 적용 )
var module = require('./custom_module');

// 1. formatted 특수문자 %d를 사용해서 module.sum( ) 에서 리턴된 숫자값을 출력
console.log('sum = %d' , module.sum(100));

// 2. formatted 특수문자 %s를 사용해서 module.var1의 문자값을 출력
console.log('var1 = %s' , module.var1);

var 변수명 = function(파라미터){ 함수식 }

# event - node.js에서 event처리는 events 모듈을 재정의해서 만들어지게 되는데, 어떤 요청에 대해 event 를 사용해서 비동기 처리를 하게되면, 
단일요청에 대한 thread 대기시간이 없어지기 때문에 동기처리에 비해 프로세스를 좀 더 효율적으로 사용할 수 있다.
비동기로 인한 callback 이벤트의 개수 증가로 가독성이 떨어지지만 성능면으로는 진보적 형태의 서버 아키텍처라 할 수 있다.
- EventEmitter : node.js의 모든 이벤트처리가 정의된 기본객체. 이벤트를 사용하기 위해서는 이 객체를 재정의해서 사용해야할 수 있다.
- on() : 이벤트를 연결하는 함수. 
 ex) requset객체에 on()함수를 이용해 'data'라는 이벤트를 캐치해서 사용
- emit() : 이벤트를 발생시키는 함수. on() 함수에서 'data'라는 이벤트가 캐치되기 위해서는 emit('data')의 형태로 이벤트를 발생시켜야 한다.

- custom_event.js
// 1. 이벤트가 정의되 있는 events 모듈 생성. 이전 버전의 process.EventEmitter() 는 deprecated!
var EventEmitter = require('events');

// 2. 생성된 이벤트 모듈을 사용하기 위해 custom_object로 초기화
var custom_object = new EventEmitter();

// 3. events 모듈에 선언되어 있는 on( ) 함수를 재정의 하여 'call' 이벤트를 처리 
custom_object.on('call', ()=> {
    console.log('called events!');
});

// 4. call 이벤트를 강제로 발생
custom_object.emit('call');

- custom_module_timer.js
var EventEmitter = require('events');
// 1. setInterval 함수가 동작하는 interval 값을 설정합니다. 1초에 한번씩 호출
var sec = 1;

// 2. timer변수를 EventEmitter 로 초기화
exports.timer = new EventEmitter();

// 3. javascript 내장함수인 setInterval 을 사용해서 1초에 한번씩 timer 객체에 tick 이벤트 발생
setInterval(function(){
    exports.timer.emit('tick');
}, sec*1000);

- call_timer.js
var module = require('./custom_module_timer');

// 1. module 내부에 선언된 timer객체를 통해 tick 이벤트를 캐치하고, 이벤트 발생시마다 현재시간을 출력
module.timer.on('tick', function(time){
    var time = new Date(); // 2. 현재 시간을 가져오기 위한 Date 객체 생성
    console.log('now:'+time);
});

# url  - 클라이언트가 요청한 주소를 parsing해서 서버내의 실제 로컬자원만 따로 처리할 수 있게 해준다.
서버 URI에 해당하는 문자열
http://www.naver.com/my_page/firstpage?section=15 // 전체 URI

[ http://www.naver.com ] [ /my_page/firstpage ] [ ?section=15 ]
        도메인                  서버URI           쿼리스트링
         
- server_request.js
var http = require('http');
var url = require('url');

var server = http.createServer(function(request,response){
  // 1. 실제 요청한 주소전체를 콘솔에 출력  
  console.log(request.url);
  var parsedUrl = url.parse(request.url);
  // 2. parsing 된 url 중에 서버URI에 해당하는 pathname 만 따로 저장
  var resource = parsedUrl.pathname;
  console.log('resource path=%s',resource);

  // 3. 리소스에 해당하는 문자열이 아래와 같으면 해당 메시지를 클라이언트에 전달
  if(resource == '/address'){
    response.writeHead(200, {'Content-Type':'text/html'});
    response.end('서울특별시 강남구 논현1동 111');
  }else if(resource == '/phone'){
    response.writeHead(200, {'Content-Type':'text/html'});
    response.end('02-3545-1237');
  }else if(resource == '/name'){
    response.writeHead(200, {'Content-Type':'text/html'});
    response.end('Hong Gil Dong');
  }else{
    response.writeHead(404, {'Content-Type':'text/html'});
    response.end('404 Page Not Found');
  }

});

// 4. 서버 포트 80번으로 변경.
server.listen(80, function(){
    console.log('Server is running...');
});
        
node server_requset.js

파일 입출력

- file_read.js (동기, 비동기 방식의 파일 읽기)
// 1. fs(파일시스템) 모듈 사용
var fs = require('fs');

// 2. 비동기방식의 파일읽기. 파일을 읽은 후 마지막 파라미터에 넘긴 callback 함수가 호출
fs.readFile('home.js', 'utf-8', function(error, data) {
    console.log('01 readAsync: %s',data);
});

// 3. 동기방식의 파일읽기. 파일을 읽은 후 data 변수에 저장
var data = fs.readFileSync('home.js', 'utf-8');
console.log('02 readSync: %s',data);


- file_write.js (동기, 비동기 방식의 파일 생성)
var fs = require('fs');

// 1. 새로 생성할 파일에 입력될 문자열
var data = "My first data...\r\nhello there!";

// 2. 비동기 방식으로 파일을 생성. 함수의 인자는 앞에서 부터 순서대로 파일명, 입력데이터, 인코딩, 콜백함수
fs.writeFile('file01_async.txt', data, 'utf-8', function(e){
    if(e){
        // 3. 파일생성 중 오류가 발생하면 오류출력
        console.log(e);
    }else{
        // 4. 파일생성 중 오류가 없으면 완료 문자열 출력
        console.log('01 WRITE DONE!');
    }
});

// 5. 동기방식은 callback 함수를 통한 오류처리를 할 수 없기 때문에 함수전체를 try 문으로 예외처리
try{
    // 6. 동기 방식으로 파일을 생성. 함수의 인자는 앞에서 부터 순서대로 파일명, 입력데이터, 인코딩
    fs.writeFileSync('file02_sync.txt', data, 'utf-8');
    console.log('02 WRITE DONE!');
}catch(e){
    console.log(e);
}

클라이언트에서 파일요청 시 처리
- hello.html (data가 될 부분)
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Hello node.js</title>
</head>
<body>
    <h1>Hello!</h1>
    처음 만들어보는 html 페이지 입니다.</br>
    good to see you~
</body>
</html>

- server_request_file.js (html을 받아서 처리할 부분)
var http = require('http');
var url = require('url');
var fs = require('fs');

var server = http.createServer(function(request,response){
  var parsedUrl = url.parse(request.url);
  var resource = parsedUrl.pathname;

  // 1. 요청된 자원이 /hello 이면
  if(resource == '/hello'){
    // 2. hello.html 파일을 읽은 후
    fs.readFile('hello.html', 'utf-8', function(error, data) {
      // 2.1 읽으면서 오류가 발생하면 오류의 내용을
      if(error){
        response.writeHead(500, {'Content-Type':'text/html'});
        response.end('500 Internal Server Error : '+error);
      // 2.2 아무런 오류가 없이 정상적으로 읽기가 완료되면 파일의 내용을 클라이언트에 전달
      }else{
        response.writeHead(200, {'Content-Type':'text/html'});
        response.end(data);
      }
    });
  }else{
    response.writeHead(404, {'Content-Type':'text/html'});
    response.end('404 Page Not Found');
  }
});

server.listen(80, function(){
    console.log('Server is running...');
});

Binary 파일처리(image, mp3, mov ...)

이미지 파일 준비 - car.jpg, car2.png, car3.jpeg

- server_request_binary.js
var http = require('http');
var url = require('url');
var fs = require('fs');

// 1. mime 모듈 추가. 서비스하려는 파일의 타입을 알아내기 위해서 필요
var mime = require('mime');

var server = http.createServer(function(request,response){

  var parsedUrl = url.parse(request.url);
  var resource = parsedUrl.pathname;

  // 2. 요청한 자원의 주소가 '/images/' 문자열로 시작하면
  if(resource.indexOf('/images/') == 0){
    // 3. 첫글자인 '/' 를 제외하고 경로를 imgPath 변수에 저장
    var imgPath = resource.substring(1);
    console.log('imgPath='+imgPath);
    // 4. 서비스 하려는 파일의 mime type
    var imgMime = mime.getType(imgPath); // lookup -> getType으로 변경됨
    console.log('mime='+imgMime);

    // 5. 해당 파일을 읽어 오는데 두번째 인자인 인코딩(utf-8) 값 없음
    fs.readFile(imgPath, function(error, data) {
      if(error){
        response.writeHead(500, {'Content-Type':'text/html'});
        response.end('500 Internal Server '+error);
      }else{
        // 6. Content-Type 에 4번에서 추출한 mime type 을 입력
        response.writeHead(200, {'Content-Type':imgMime});
        response.end(data);
      }
    });
  }else{
    response.writeHead(404, {'Content-Type':'text/html'});
    response.end('404 Page Not Found');
  }
});

server.listen(80, function(){
    console.log('Server is running...');
});

Streaming 서비스
node js는 이벤트 Loop 기반의 비동기 처리를 지원하기 때문에 대용량 파일을 구간별로 작게 나누어서 처리하는 작업에 강점을 가지고 있다.

fs.readFile('movie.mp4', function(error, data) {
    request.end(data);
});

위와 같은 코드일 경우 서버에서 파일을 다 읽은 후에 파일읽기가 완료되면 클라이언트로 한번에 전송하게 된다.
이후 클라이언트는 서버에서 데이터를 전송이 끝날 때 까지 대기를 하게 되고, 데이터 용량이 클 경우 대기시간도 길어지고, 요청이 많을 수록 서버의 효율이 떨어진다
stream은 이런 단점을 보완하는, 데이터를 다 읽거나 쓰지 않아도 중간에 처리할 수 있도록 해준다. 

- html/movie_player.html (HTML5의 <vidoe>로 big.mp4 실행)
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Movie Player</title>
</head>
<body>
    <h1>Movie Player</h1>
    <video width="320" height="240" controls>
        <source src="../movie/big.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
</body>
</html>

streaming_movie.js
var http = require('http');
var url = require('url');
var fs = require('fs');

var server = http.createServer(function(request,response){

  var parsedUrl = url.parse(request.url);
  var resource = parsedUrl.pathname;
  console.log('resource='+resource);

  var resourcePath = '.'+resource;
  console.log('resourcePath='+resourcePath);

  // html 페이지 요청이 들어왔을 경우는 텍스트 파일 처리
  if(resource.indexOf('/html/') == 0){
    fs.readFile(resourcePath, 'utf-8', function(error, data) {
      if(error){
        response.writeHead(500, {'Content-Type':'text/html'});
        response.end('500 Internal Server '+error);
      }else{
        response.writeHead(200, {'Content-Type':'text/html'});
        response.end(data);
      }
    });

  }else if(resource.indexOf('/movie/') == 0){
    // 1. stream 생성
    var stream = fs.createReadStream(resourcePath);
    // 2. 잘게 쪼개진 stream 이 몇번 전송되는지 확인하기 위한 count
    var count = 0;
    // 3. 잘게 쪼개진 data를 전송할 수 있으면 data 이벤트 발생 
    stream.on('data', function(data) {
      count = count + 1;
      console.log('data count='+count);
      // 3.1. data 이벤트가 발생되면 해당 data를 클라이언트로 전송
      response.write(data);
    });

    // 4. 데이터 전송이 완료되면 end 이벤트 발생
    stream.on('end', function () {
      console.log('end streaming');
      // 4.1. 클라이언트에 전송완료를 알림
      response.end();
    });

    // 5. 스트림도중 에러 발생시 error 이벤트 발생
    stream.on('error', function(err) {
      console.log(err);
      // 5.2. 클라이언트로 에러메시지를 전달하고 전송완료
      response.end('500 Internal Server '+err);
    });
  }else{
    response.writeHead(404, {'Content-Type':'text/html'});
    response.end('404 Page Not Found');
  }

});

server.listen(80, function(){
    console.log('Server is running...');
});
